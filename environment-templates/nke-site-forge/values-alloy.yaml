alloy:
  configMap:
    content: |-
      import.file "log_levels" {
        filename = "/etc/alloy.modules/log-levels.alloy"
      }

      // Journal Logs
      loki.relabel "journal" {
        forward_to = []

        rule {
          source_labels = ["__journal__systemd_unit"]
          target_label  = "unit"
        }

        rule {
          source_labels = ["__journal__transport"]
          target_label  = "journal_transport"
        }

        rule {
          source_labels = ["__journal_priority_keyword"]
          target_label  = "level"
        }

        rule {
          source_labels = ["__journal__hostname"]
          target_label  = "host_name"
        }
      }

      loki.source.journal "read" {
        forward_to    = [loki.process.pre_process.receiver]
        relabel_rules = loki.relabel.journal.rules
        max_age       = "5m"
        path          = "/var/log/journal"
        labels        = {component = "loki.source.journal"}
      }
      // Cluster Event
      loki.source.kubernetes_events "cluster_events" {
        forward_to = [loki.process.pre_process.receiver]
        job_name   = "integrations/kubernetes/eventhandler"
        log_format = "logfmt"
      }

      // Pod Logs
      discovery.kubernetes "pods" {
        role = "pod"
        selectors {
          role = "pod"
        }
      }

      discovery.relabel "pod_logs" {
        targets = discovery.kubernetes.pods.targets
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          action = "replace"
          target_label = "namespace"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          action = "replace"
          target_label = "pod"
        }
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "container"
        }
        rule {
          source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
          separator = "/"
          action = "replace"
          replacement = "$1"
          target_label = "job"
        }
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
          regex         = "(.+)"
          target_label  = "app_kubernetes_io_name"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
          regex         = "(.+)"
          target_label  = "job"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          separator = "/"
          action = "replace"
          replacement = "/var/log/pods/*$1/*.log"
          target_label = "__path__"
        }

        // set the container runtime as a label
        rule {
          action = "replace"
          source_labels = ["__meta_kubernetes_pod_container_id"]
          regex = "^(\\S+):\\/\\/.+$"
          replacement = "$1"
          target_label = "tmp_container_runtime"
        }
      }

      discovery.relabel "filtered_pod_logs" {
        targets = discovery.relabel.pod_logs.output
        rule {  // Drop anything with a "falsy" annotation value
          source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_autogather"]
          regex = "(false|no|skip)"
          action = "drop"
        }
      }

      local.file_match "pod_logs" {
        path_targets = discovery.relabel.filtered_pod_logs.output
      }

      loki.source.file "pod_logs" {
        targets    = local.file_match.pod_logs.targets
        forward_to = [loki.process.pod_logs.receiver]
      }

      loki.process "pod_logs" {
        stage.match {
          selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
          // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
          stage.cri {}

          // Set the extract flags and stream values as labels
          stage.labels {
            values = {
              flags  = "",
              stream  = "",
            }
          }
        }

        stage.match {
          selector = "{tmp_container_runtime=\"docker\"}"
          // the docker processing stage extracts the following k/v pairs: log, stream, time
          stage.docker {}

          // Set the extract stream value as a label
          stage.labels {
            values = {
              stream  = "",
            }
          }
        }

        // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
        // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
        // container runtime label as it is no longer needed.
        stage.label_drop {
          values = [
            "filename",
            "tmp_container_runtime",
          ]
        }

        stage.drop {
          older_than          = "5m"
          drop_counter_reason = "log is too old"
        }

        forward_to = [loki.process.pre_process.receiver]
      }

      loki.process "pre_process"{
        forward_to = [log_levels.default_level.set.receiver]
          stage.replace {
            expression = "(?i)(type=)"
            replace    = "level="
          }
      }

      log_levels.default_level "set" {
        forward_to    = [log_levels.klog_format.parse.receiver]
        default_level = "unknown"
      }

      log_levels.klog_format "parse" {
        forward_to    = [log_levels.zerolog_format.parse.receiver]
        default_level = "unknown"
      }

      log_levels.zerolog_format "parse" {
        forward_to    = [log_levels.logfmt_format.parse.receiver]
        default_level = "unknown"
      }

      log_levels.logfmt_format "parse" {
        forward_to    = [log_levels.unknown_format.parse.receiver]
        default_level = "unknown"
      }

      log_levels.unknown_format "parse" {
        forward_to    = [log_levels.normalize_level.default.receiver]
        default_level = "unknown"
      }

      log_levels.normalize_level "default" {
        forward_to = [loki.process.logs_service.receiver]
      }

      // Logs Service
      remote.kubernetes.secret "logs_service" {
        name = "grafana-loki-secret"                
        namespace = "monitoring"
      }

      loki.process "logs_service" {
        stage.static_labels {
            values = {
              cluster   = "${ENV_NAME}",
              env       = "prod",
              csp       = "forgeazure",
              platform  = "forge-nke",
              log_agent = "alloy-logging",
              node      = sys.env("HOSTNAME"),
            }
        }
        stage.drop {
          older_than          = "5m"
          drop_counter_reason = "log is too old"
        }
        stage.drop {
          expression          = ".*========.*"
          drop_counter_reason = "noise"
        }
        stage.drop {
          expression          = "^\\s+$"
          drop_counter_reason = "whitespace only"
        }

        forward_to = [loki.process.drop_by_log_levels.receiver, loki.process.cluster_events.receiver]
      }
      loki.process "cluster_events" {
        forward_to = [loki.process.pack_labels.receiver]
        stage.match {
          selector =  "{job=\"integrations/kubernetes/eventhandler\"}"
          action = "keep"
          stage.decolorize {}
        }
        stage.match {
          selector =  "{job!=\"integrations/kubernetes/eventhandler\"}"
          action = "drop"
        }
      }

      loki.process "drop_by_log_levels"{
        forward_to = [loki.process.pack_labels.receiver]
        stage.drop {
          expression = "(?i).*(debug|info|trace|Normal).*"
          drop_counter_reason = "below warn log level"
        }
        stage.drop {
          source = "level"
          value  = "info"
        }
        stage.drop {
          source = "level"
          value  = "debug"
        }
      }

      loki.process "pack_labels" {
        forward_to = [loki.write.logs_service.receiver]
        stage.pack {
          ingest_timestamp = false
          labels = [
            "app_kubernetes_io_name",
            "container",
            "flags",
            "host_name",
            "job",
            "journal_transport",
            "platform",
            "tenant",
            "log_agent",
            "node",
            "pod",
            "stream",
            "unit",
          ]
        }
      }

      // Loki                                       
      loki.write "logs_service" {
        endpoint {
          url = convert.nonsensitive(remote.kubernetes.secret.logs_service.data["host"]) + "/loki/api/v1/push"

          basic_auth {
            username = convert.nonsensitive(remote.kubernetes.secret.logs_service.data["username"])
            password = remote.kubernetes.secret.logs_service.data["password"]
          }
        }
      }

      logging {
        level  = "warn"
        format = "logfmt"
      }
  enableReporting: false
  mounts:
    dockercontainers: true
    extra:
      - mountPath: /etc/alloy.modules
        name: modules
    varlog: true
  resources:
    requests:
      cpu: 1
      ephemeral-storage: 2Gi
      memory: 120Mi
configReloader:
  image:
    repository: j7sbcjl3qgta/ghcr_io__jimmidyson__configmap-reload
    tag: v0.14.0
controller:
  tolerations: null
  volumes:
    extra:
      - configMap:
          name: logging-modules
        name: modules
global:
  image:
    pullSecrets:
      - name: ngc-registry-nke-imagepull
    registry: nvcr.io
image:
  repository: j7sbcjl3qgta/docker_io__grafana__alloy
  tag: v1.4.3
